try:
    print(1 / 1)
except Exception as e:
    print("被除数不能为0")
else:
    print("正确的格式")
import numpy as py

# 直接使用numpy这个库，生成一个数组，数组的方式，是用列表形式存放数据的
a = py.array([1, 2, 3, 4])
b = py.array([1, 2, 3, 4])
# 直接+1的话，里面的所有数都+1，两个数组直接+的话，里面对应的直接+
print(a + 1)
print(a + b)
# 生成5个0的浮点数
c = py.zeros(5)
print(c)
# 默认生成全部是1的浮点数，里面个数几个，生成几个
print(py.ones(5))
# 可以修改，int的话，就是生成的全部是int的1，类型可以变，
print(py.ones(5, dtype=int))
# 修改数组元素,里面是几，全部的都被替换，fill里面的，替换的时候，替换成a的类型，浮点数的话，也转换成int
a.fill(5)
print(a)
# 修改数据类型
a = a.astype('float')
a.fill(3.4)
print(a)

# 数据范围,左闭合，右开,步长是2，从第二个开始，数两个，包括第二个，
c = py.arange(1, 10, 2)
print(c)
# 等差数列,左闭，右闭
print(py.linspace(1, 10, 32))
# 生成随机数,rand是0-10之间的小数
print(py.random.rand(10))
# 生成的是服从正太分布的数
print(py.random.randn(10))
# 生成随机整数，在一定的范围内部，可以重复，随机的
print(py.random.randint(1, 10, 100))
# 查看a以及a里面的数的类型
print(type(a))
print(a.dtype)
# 查看数目
print(a.size)
# 切片，左闭，右开，按照数组索引下标去完成检索
c = py.array([1, 54, 75, 34, 54, 23])
print(c[1:4])
# 第一个就是从第几个开始，第二个是取到第几个结束，-的话，是倒数的方式进行
print(c[-4:3])
# 记住准确的，第一个数，就是从第几个索引开始，第三个是步长，第二个是是到索引那个结束，从左往右
print(c[-1:])
# 最后一个步长，2表示从一个的后面一个算起，往后数两个，第二个的时候，包括进去，说白了就是，中间间隔i-1个
print(c[::2])
print("多维数组++++++++++++++++++++")
i = py.array([[1, 23, 6], [4, 5, 75]])
# 查看二维数组的形状，就是几行，几列
p = i.shape
print(p)
# 查看纬度
print(i.ndim)
# 修改数据
i[1, 2] = 4
print(i)
# 输出索引这个的数据，这个索引位置上的数据，不管是什么，直接输出
print(i[1])
# 第一个：是从头开始然后到最后，要找的数据是索引1的，第二个数据
print(i[:, 1])
m = py.array([[1, 23, 45, 67, 86], [2, 3, 46, 7, 8], [24, 31, 46, 6, 7], [24, 311, 416, 6, 7], [24, 31, 426, 62, 7]])
# 1表示从第二行开始，第一个：表示后面的所有行的内容数据，数据怎么取，3是从限制好的每一行的第4个位置开始取，取到最后
print(m[1:, 3:])
# 得到每一行的索引为2的数字
print(m[:, 2])
# 先取出行，然后在行里面在规定好要取出来的每一个数据，从索引2开始，取到最后，中间间隔1个，i-1,然后在从每一行里面取数据，从头开始，中间间隔1个
print(m[2::2, ::2])
# 数组的话，是引用类型的，可以用复制的方式去改变一个数组
f = py.array([1, 3, 5, 6, 2, 7, 8])
v = f[::2].copy()
print(v)
v[1] = 45
print(f)

# 花式索引,先把索引设置好，然后在把这个索引放在f里面，在赋值一个y，然后在从y里面把数据取出来
# [3 5 2]
index = [1, 2, -3]
y = f[index]
print(y)
# 花式索引，波尔值的方式去设置
# [1 3 2 8]
# 根据不是0的位置上的索引，把f里面的数据取出来，不是0的就是true，因此按照true的方式去取数据
j = py.array([1, 2, 0, 0, 2, 0, 1], dtype=bool)
print(f[j])
# 先取数行，然后在取出列，前后一一的对应
# [ 1  3 46  6  7]
m1 = py.array([[1, 23, 45, 67, 86], [2, 3, 46, 7, 8], [24, 31, 46, 6, 7], [24, 311, 416, 6, 7], [24, 31, 426, 62, 7]])
print(m1[(0, 1, 2, 3, 4), (0, 1, 2, 3, 4)])
# 从第三行开始，取到最后，每一行，按照后面的索引值方式取
# [[ 24 416   7]
#  [ 24 426   7]]
print(m1[3:, (0, 2, 4)])
# 1表示第几行可以取数据，2表示每一行的索引位置，
# [ 45  46 426]
# 注意：花式索引，不是按照应用地址的方式，是一个新的
print(m1[py.array([1, 0, 1, 0, 1], dtype=bool), 2])

print("+++++++++++++++++++++++++++++++++++++++")
# where的使用，返回索引位置
k = py.array([1, 29, 4, 5, 78])
# (array([1, 4], dtype=int64),),得到的是一个索引的位置上的数据
print(py.where(k > 20))
# 输出那个位置是false，是true
# [array([False,  True, False, False,  True])]
# [29 78]
print([k > 20])
# 取出来的是那个索引位置上的数
print(k[k > 20])

# 数据类型的转变
# 可以在设置数据的时候，就指定好
# [1. 3. 4.]
# [ True  True  True  True]
# [ 1.  3.  4. 89.]
# [0 1 3 2]
print(py.array([1, 3, 4], dtype=float))
r = py.array([1, 3, 89, 4], dtype=float)
# 指定好类型后，直接输出
print(py.asarray(r, dtype=bool))
# 对r这个数组排序，得到的一个排号序列的值，不会覆盖之前的值
print(py.sort(r))
# 按照以前的位置，先排号，然后在把以前的索引位置填写在这个新的位置上面
print(py.argsort(r))
# 基本方法
# 89.0
# 24.25
# 37.399030736103306
# [[1864.91666667    0.        ]
#  [   0.            0.        ]]
print(r.max())
# 平均值
print(r.mean())
# 标准差
print(r.std())
# 相关系数矩阵
# 连个数组之间的矩阵关系
print(py.cov(r, a))

# reshape
# 改变数组的形状，这种形式不改变以前数据的形式shape会改变
print(r.reshape(2, 2))
print(r)
# 转置，以前的那个不改变
# [[ 1.  3.]
#  [89.  4.]]
# [ 1.  3. 89.  4.]
# [[ 1. 89.]
#  [ 3.  4.]]
print(r.reshape(2, 2).T)
print("数组的拼接+++++++++++++++++++++++++++++++++++++++++")
o1 = py.array([[1, 2, 3], [2, 3, 6]])
o2 = py.array([[4, 5, 7], [0, 5, 6]])
# 直接把o2,放在o1的后面
# [[1 2 3]
#  [2 3 6]
#  [4 5 7]
#  [0 5 6]]
print(py.concatenate((o1, o2)))
# [[1 2 3 4 5 7]
#  [2 3 6 0 5 6]]
print(py.concatenate((o1, o2),axis=1))
